classdef Chain < handle
    % This class represents supply chains

    properties %% Chain class properties
        chainId            % ID number
        supplier           % Supplier object
        inventories        % Array of Inventory objects
        numOfInventories   % Number of inventories
        phyLinks           % Array of PhyLink objects (transport between inventories)
        demander           % Demand object (at the end of the chain)
        location           % Chain location (optional for plotting)
    end

    methods
        function obj = Chain(chainId, numOfInventories)
            disp(['Started creating chain ', num2str(chainId)])
            obj.chainId = chainId;

            % Physical parameters (start and end points of the chain)
            obj.location = [0, 100*chainId; 100*(numOfInventories+1), 100*chainId]; 

            % Create a supplier
            sizeS = 35;
            obj.supplier = Supply(chainId, obj.location(1,:), sizeS);

            % Create inventories as a cell array (to store object references)
            sizeI = 35;
            invenList = cell(1, numOfInventories);
            for k = 1:numOfInventories
                inventory = Inventory(k, obj.location(1,2), sizeI);
                invenList{k} = inventory;
            end
            obj.inventories = invenList;
            obj.numOfInventories = numOfInventories;

            % Create a demander
            sizeD = 35;
            obj.demander = Demand(chainId, obj.location(2,:), sizeD);

            % Create phyLinks and assign them to the supplier, inventories, and demander
            phyLinks = cell(1, numOfInventories + 1);  % One link for each transition
            for k = 1:(numOfInventories+1)
                phyLinkId = numOfInventories * (chainId - 1) + k;
                if k == 1
                    % Link from supplier to the first inventory
                    location = [obj.supplier.location; obj.inventories{k}.location];
                    location(1,1) = location(1,1) + sizeS/2; 
                    location(2,1) = location(2,1) - sizeI/2; 
                    tranDelay = 4;
                    phyLink = PhyLink(phyLinkId, location, tranDelay, obj.supplier, obj.inventories{k}); 
                    % Assign phyLink to the first inventory's phyLinkIn and supplier's phyLinkOut
                    obj.inventories{k}.phyLinkIn = phyLink;
                    obj.supplier.phyLinkOut = phyLink;
                elseif k <= numOfInventories
                    % Link between two consecutive inventories
                    location = [obj.inventories{k-1}.location; obj.inventories{k}.location];
                    location(1,1) = location(1,1) + sizeI/2; 
                    location(2,1) = location(2,1) - sizeI/2; 
                    tranDelay = 5;
                    phyLink = PhyLink(phyLinkId, location, tranDelay, obj.inventories{k-1}, obj.inventories{k});
                    % Assign phyLink to the inventories' phyLinkIn and phyLinkOut
                    obj.inventories{k-1}.phyLinkOut = phyLink;  % Outgoing link for previous inventory
                    obj.inventories{k}.phyLinkIn = phyLink;     % Incoming link for current inventory
                else
                    % Link from the last inventory to the demander
                    location = [obj.inventories{k-1}.location; obj.demander.location];
                    location(1,1) = location(1,1) + sizeI/2; 
                    location(2,1) = location(2,1) - sizeD/2; 
                    tranDelay = 1;
                    phyLink = PhyLink(phyLinkId, location, tranDelay, obj.inventories{k-1}, obj.demander);
                    % Assign phyLink to the last inventory's phyLinkOut and demander's phyLinkIn
                    obj.inventories{k-1}.phyLinkOut = phyLink;
                    obj.demander.phyLinkIn = phyLink;
                end
                phyLinks{k} = phyLink;  % Store the PhyLink reference
            end 
            obj.phyLinks = phyLinks;

            disp('Finished creating a chain...')
        end

        function update(obj)
            % Step 1: Demand generation
            obj.demander.generateDemand();

            % Step 2: Inventories compute orders based on downstream demand
            for i = obj.numOfInventories:-1:1
                obj.inventories{i}.computeOrder();  % Compute orders from downstream
            end
            
            % Step 3: Supplier provides products based on the first inventory's request
            obj.supplier.supplyProducts();
            
            % Step 3: Update state of all inventories and demander:
            % 
            for i = 1:obj.numOfInventories
                obj.inventories{i}.updateState();
            end

            % Step 4: Transport products through each PhyLink
            for i = 1:length(obj.phyLinks)
                obj.phyLinks{i}.transportGoods();
            end

            obj.demander.updateState();
        end

        function outputArg = draw(obj)
            obj.supplier.draw();
            for k = 1:1:obj.numOfInventories
                obj.inventories{k}.draw();
                obj.phyLinks{k}.draw();
            end
            obj.phyLinks{k+1}.draw();
            obj.demander.draw();            
        end
    end
end